<!DOCTYPE html>
<html>
	<head>
		<title>Cubes. 1 lesson Three.js </title>
		<style>
			body { maskargin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>

		<script src="../libraries/three.js-r87/build/three.min.js"></script>
		<script src="../libraries/three.js-r87/examples/js/loaders/ColladaLoader.js"></script>

		<script src="../libraries/three.js-r87/examples/js/libs/stats.min.js"></script>

        <script src="libs/OrbitControls.js"></script>

		<script>


    var Container, Stats = new Stats();
    Container = document.createElement( 'div' );
    document.body.appendChild( Container );
    Container.appendChild( Stats.dom);
				var ColladaLoader = new THREE.ColladaLoader();
				var prom = load3DSceneByCollada(ColladaLoader, "Bitcoin4.dae");
				prom.then(onSceneLoaded);
			

/*

 */            
		function onSceneLoaded(collada)
			{
				var scene = new THREE.Scene();
				var camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.1, 1000);
				var renderer = new THREE.WebGLRenderer(), t = 0;


				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);
				camera.position.set(0, 0, 40);
				/*var loader = new THREE.ColladaLoader(), Points;
				loader.load("Bitcoin.dae", function (result) {
					Points = result.scene.children[2].children[0].geometry.vertices;
					scene.add(result.scene);
				});*/
				var Points, Dots = [], InitDots = [], CurrentDots = [], scale = 10;
				Points = collada.scene.children[0].children[0].geometry.vertices;
				/*for(i = 0; i < collada.scene.children.length; i++) {
				if(collada.scene.children[i].geometry) {
				for(j = 0; j < collada.scene.children[i].geometry.vertices.length; j++) {
				Points.push(collada.scene.children[i].geometry.vertices[j]);
				}
				}
				}*/
				//var Line, Geometry = new THREE.Geometry(), Material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1, linewidth: 3, vertexColors: THREE.VertexColors } );
				 
                var controls = new THREE.OrbitControls( camera);
                scene.userData.controls = controls;   
			    for (var i = 0; i < Points.length; i ++ ) 
			    {
			    	var geometry = new THREE.SphereBufferGeometry( 0.2, 32, 32 );
					var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
					var sphere = new THREE.Mesh( geometry, material );

				    sphere.position.x=Points[i].getComponent(0)*scale;
				    sphere.position.y=Points[i].getComponent(1)*scale;
				    sphere.position.z=Points[i].getComponent(2)*scale;
					//sphere.position = Points[i];
					Dots.push(sphere);
					scene.add( Dots[i] );

	        		//Geometry.vertices.push( Points[ i ] );
			    }
			    /*
			     var geometry = new THREE.Geometry();
                    var geometry0 = new THREE.Geometry();
                    if ( views[n].lattice ) {
                        var range = balls / 2;
                        for ( var i = -range ; i <= range ; i++ ) {
                            for ( var j = -range ; j <= range ; j++ ) {
                                for ( var k = -range ; k <= range ; k++ ) {
                                    geometry.vertices.push( new THREE.Vector3( i, j, k ) );
                                    geometry0.vertices.push( new THREE.Vector3( i, j, k ) );
                                }
                            }
                        }
                    } else {
                        for ( var m = 0 ; m < Math.pow( balls, 4 ) ; m++ ) {
                            var i = balls * Math.random() - balls / 2;
                            var j = balls * Math.random() - balls / 2;
                            var k = balls * Math.random() - balls / 2;
                            geometry.vertices.push( new THREE.Vector3( i, j, k ) );
                            geometry0.vertices.push( new THREE.Vector3( i, j, k ) );
                        }
                    }	

				//Line = new THREE.Line( Geometry,  Material );
				//scene.add( Line );
				//scene.add(collada.scene);

/*
				for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
				{				
					var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
					var directionVector = globalVertex.sub( MovingCube.position );
					
					var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
					var collisionResults = ray.intersectObjects( collidableMeshList );
					if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
						appendText(" Hit ");
				}	

			*/	
				animate();
			


            function animate () {

                requestAnimationFrame( animate );
                render();

            }
				function render() {
				//if (t< 100 && way)

						t++;
								var t1 = t /5	;
					var st =Math.sin(t1)*10, sgt = Math.sign(st);
				for (var i = 0; i < Dots.length; i ++ ) {
			


				    Dots[i].position.x= Points[i].getComponent(0)*st*sgt;
				    //Dots[i].position.y= Points[i].getComponent(1)*st*sgt;
				   // Dots[i].position.z= Points[i].getComponent(2)*st*sgt;

				}
			    
					 /* for ( var i = 0 ; i < Dots.length ; i++ ) {
                        var v0 = Dots[i].position;
                        var v = displacement( v0.getComponent(0), v0.getComponent(1), v0.getComponent(2), t/30);


                        Dots[i].set( v.getComponent(0) + v0.getComponent(0), v.getComponent(1)+ v0.getComponent(1), v.getComponent(2) + v0.getComponent(2) );
                    }*/
                    //Dots.verticesNeedUpdate = true;

      				  Stats.update();
					requestAnimationFrame(render);
					renderer.render(scene, camera);
					
				}
			}
		function load3DSceneByCollada(loader, file_str){
			  return new Promise(
				    function(resolve) 
				    {
				        loader.load(
				            file_str,
				            function(collada) 
				            {											
								resolve(collada);
				            }
				        );
				    }
				);
			};

		function displacement( x, y, z, t ) {
               /* var x1 = Math.sin(x - t), 
                y1 = Math.sin(y - t), 
                z1 = Math.sin(z - t), 
                m = 0;
                if (x1<m) 
                    x1 =m;
                if (y1<m) 
                    y1 =m;
                if (z1<m) 
                    z1 =;
                */
                
                //return new THREE.Vector3( x, y, z);
                //return new THREE.Vector3( x*Math.sign(Math.sin(t))*Math.sin(t)/2, y*Math.sign(Math.sin(t))*Math.sin(t)/2, z*Math.sign(Math.sin(t))*Math.sin(t)/2);//Math.sin(y+t), Math.sin(z+t));// Math.cos(z + t)); -Math.sin(y - t)
                return new THREE.Vector3( x*Math.sign(Math.sin(t))*Math.sin(t)/2, y*Math.sign(Math.sin(t))*Math.sin(t)/2, z*Math.sign(Math.sin(t))*Math.sin(t)/2);
            };
		</script>
		<script>
		 parent.d
		</script>
	</body>